generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = "postgresql://postgres:piyupiyu@168.138.112.214:5432/vibe?schema=public"
}

model Profile {
  id        Int      @id @default(autoincrement())
  bio       String?
  interests String[]
  avatar    Bytes?   // Store profile picture as blob
  photos    Bytes[]  // Store multiple photos (max 10)
  location  String?  // User location (city, country)
  latitude  Float?   // Location coordinates
  longitude Float?   // Location coordinates
  mbtiType  MBTIType? // MBTI personality type
  userId    Int      @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model User {
  id        Int         @id @default(autoincrement())
  name      String?     @db.VarChar(255)
  email     String      @unique @db.VarChar(255)
  password  String?     @db.VarChar(255)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt @default(now())
  Profile   Profile?
  userMedia userMedia[]
  matches   Match[]     @relation("UserMatches")
  matchedBy Match[]     @relation("MatchedByUsers")
  
  // Swipe relations
  swipes    Swipe[]     @relation("UserSwipes")
  swipedBy  Swipe[]     @relation("SwipedByUsers")
  
  // Connection relations
  connections1 Connection[] @relation("UserConnections1")
  connections2 Connection[] @relation("UserConnections2")
  
  // Message relation
  messages Message[]
}

model Media {
  id          Int         @id @default(autoincrement())
  type        MediaType
  apiId       Int
  title       String
  description String
  genres      String[]
  image       String
  meta        Json
  userMedias  userMedia[]
}

model userMedia {
  id        Int       @id @default(autoincrement())
  userId    Int
  mediaId   Int
  type      MediaType
  status    Status
  rating    Int?
  review    String?
  progress  Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  media     Media     @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Match {
  id              Int      @id @default(autoincrement())
  userId          Int
  matchedUserId   Int
  matchPercentage Float    @default(0)
  commonMediaIds  Int[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user        User @relation("UserMatches", fields: [userId], references: [id], onDelete: Cascade)
  matchedUser User @relation("MatchedByUsers", fields: [matchedUserId], references: [id], onDelete: Cascade)
}

model Swipe {
  id        Int       @id @default(autoincrement())
  swiperId  Int       // User who swiped
  swipedId  Int       // User who was swiped on
  action    SwipeAction // LIKE or PASS
  createdAt DateTime  @default(now())
  
  swiper User @relation("UserSwipes", fields: [swiperId], references: [id], onDelete: Cascade)
  swiped User @relation("SwipedByUsers", fields: [swipedId], references: [id], onDelete: Cascade)
  
  @@unique([swiperId, swipedId]) // Prevent duplicate swipes
}

model Connection {
  id        Int      @id @default(autoincrement())
  user1Id   Int
  user2Id   Int
  status    ConnectionStatus @default(PENDING)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user1 User @relation("UserConnections1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("UserConnections2", fields: [user2Id], references: [id], onDelete: Cascade)
  
  messages Message[]
  
  @@unique([user1Id, user2Id])
}

model Message {
  id           Int        @id @default(autoincrement())
  connectionId Int
  senderId     Int
  content      String
  messageType  MessageType @default(TEXT)
  isRead       Boolean    @default(false)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  sender     User       @relation(fields: [senderId], references: [id], onDelete: Cascade)
}

enum SwipeAction {
  LIKE
  PASS
}

enum ConnectionStatus {
  PENDING
  MATCHED
  BLOCKED
}

enum MessageType {
  TEXT
  IMAGE
  SYSTEM
}

enum MediaType {
  ANIME
  MOVIE
  SHOW
  BOOK
}

enum Status {
  WATCHING
  COMPLETED
  PLAN_TO_WATCH
  DROPPED
}

enum MBTIType {
  INTJ
  INTP
  ENTJ
  ENTP
  INFJ
  INFP
  ENFJ
  ENFP
  ISTJ
  ISFJ
  ESTJ
  ESFJ
  ISTP
  ISFP
  ESTP
  ESFP
}
